// 내 풀이

/*
    우선 숫자가 들어가는 좌표를 (x, y) 좌표의 합에 따라 구분하여 관찰하여 그 경향성에 맞게 이중 반복문을 사용해 구현했다.
    
    e.g)
        입력 : 4 6
        
        (0, 0)
        (0, 1) -> (1, 0)
        (0, 2) -> (1, 1) -> (2, 0)
        (0, 3) -> (1, 2) -> (2, 1) -> (3, 0)
        (0, 4) -> (1, 3) -> (2, 2) -> (3, 1)
        (0, 5) -> (1, 4) -> (2, 3) -> (3, 2)
        (1, 5) -> (2, 4) -> (3, 3)
        (2, 5) -> (3, 4)
        (3, 5)

        --> (x, y) 의 합이 0에서 n+m-2까지 생김을 알 수 있다. (예시에선, 4+6-2 = 8)
            이 값에 따라 처음 반복문을 설정했다. (행의 개수만큼)
            각 행의 열들을 보면 (x, y) 좌표는 x+=1, y-=1 의 경향성을 보인다. 다만, 그 값은 0보다 크며, 최초 입력 n-1, m-1 보다 크지 않으며, 좌표의 합은 i를 유지한다.
            --> 이 조건에 맞게 구현했다.

*/

#include <iostream>

using namespace std;

int n, m;

int main() {
    cin >> n >> m;

    int mat[101][101];

    int x = 0;
    int y = 0;
    int cnt = 1;
    mat[x][y] = 1;
    for (int i = 1; i <= n+m-2; i++) {
        if (y < m-1) y++;
        else x++;

        int x_i = x;
        int y_i = y;
        while ( 0 <= x_i && x_i <= n-1 && 
                0 <= y_i && y_i <= m-1 &&
                x_i+y_i == i) {
            cnt++;
            mat[x_i][y_i] = cnt;
            x_i++;
            y_i--;
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cout << mat[i][j] << ' ';
        }
        cout << '\n';
    }

    return 0;
}
